<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU FDE Cycle Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            height: 100vh; /* Fit in single viewport height */
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto; /* Allow scrolling if content overflows on smaller screens */
        }

        /* Main container for the whole application */
        .container {
            display: flex;
            gap: 20px;
            max-width: 95vw; /* Use vw for better fit */
            width: 100%;
            height: fit-content; /* Adjust height based on content */
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            padding: 25px;
            flex-wrap: wrap; /* Allow main sections to wrap */
        }

        /* Left sidebar for controls and instructions */
        .controls-panel {
            flex: 0 0 280px; /* Fixed width sidebar */
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding-right: 20px;
            border-right: 1px solid #eee;
        }

        .controls-panel h2 {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.5em;
            padding-bottom: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-weight: 600;
            color: #555;
        }

        .input-group input[type="text"] {
            padding: 10px 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.2s ease;
        }

        .input-group input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button.primary {
            background-color: #007bff;
            color: #fff;
        }

        button.primary:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        button.secondary {
            background-color: #6c757d;
            color: #fff;
        }

        button.secondary:hover {
            background-color: #5a6268;
            transform: translateY(-1px);
        }

        button.disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .predefined-instructions {
            margin-top: 15px;
            border-top: 1px solid #f0f0f0;
            padding-top: 15px;
        }

        .predefined-instructions h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 1.2em;
        }

        .predefined-instructions .instruction-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .predefined-instructions button {
            background-color: #e9ecef;
            color: #333;
            text-align: left;
            padding: 10px 15px;
            border: 1px solid #dee2e6;
        }

        .predefined-instructions button:hover {
            background-color: #cfd8dc;
        }

        /* Main simulation area */
        .simulation-area {
            flex: 1; /* Takes up remaining space */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .cpu-layout {
            display: grid;
            /* New compact grid layout */
            grid-template-areas:
                "pc   mar  mdr  ir"
                "cu   alu  .    ."
                "r1   r2   r3   r4"
                "r5   .    mem  mem";
            grid-template-columns: repeat(4, 1fr); /* Four equal columns */
            grid-template-rows: repeat(4, minmax(80px, auto)); /* Four rows with min height */
            gap: 15px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.05);
            position: relative; /* For absolute positioning of data movement animations */
            min-height: 350px; /* Ensure space for animations */
            align-items: center; /* Center items vertically */
            justify-items: center; /* Center items horizontally */
        }

        .cpu-component {
            background-color: #e0e0e0;
            border: 1px solid #bbb;
            border-radius: 8px;
            padding: 10px 8px; /* Slightly reduced padding */
            text-align: center;
            font-weight: 600;
            font-size: 0.9em;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            min-width: 70px; /* Slightly smaller min-width */
            transition: all 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 90px; /* Fixed height for consistent layout */
        }

        .cpu-component .label {
            font-size: 0.75em; /* Slightly smaller font for label */
            color: #555;
            margin-bottom: 5px;
        }

        .cpu-component .value {
            font-size: 1em; /* Adjusted font size */
            color: #000;
            word-break: break-all; /* Allow long values to break */
        }

        .cpu-component.active {
            background-color: #d1ecf1; /* Light blue */
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
            transform: scale(1.03);
        }

        /* Specific positioning for components using grid areas */
        #pc { grid-area: pc; }
        #mar { grid-area: mar; }
        #mdr { grid-area: mdr; }
        #ir { grid-area: ir; }
        #cu { grid-area: cu; }
        #alu { grid-area: alu; }
        #r1 { grid-area: r1; }
        #r2 { grid-area: r2; }
        #r3 { grid-area: r3; }
        #r4 { grid-area: r4; }
        #r5 { grid-area: r5; }
        #memory-concept { grid-area: mem; }


        #memory-concept {
            background-color: #c9e0f3; /* Lighter blue */
            border: 1px solid #8cb1e3;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9em;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Register and Explanation Panels */
        .info-panel {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow panels to wrap */
        }

        .register-panel, .explanation-panel {
            background-color: #eaf6ff; /* Very light blue */
            border: 1px solid #b3d9ff;
            border-radius: 10px;
            padding: 20px;
            flex: 1;
            min-width: 280px; /* Minimum width for panels */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .register-panel h3, .explanation-panel h3 {
            color: #007bff;
            margin-top: 0;
            font-size: 1.3em;
            padding-bottom: 8px;
            border-bottom: 1px solid #cce5ff;
        }

        .register-list {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two columns for label and value */
            gap: 8px;
            margin-top: 10px;
        }

        .register-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px dotted #e0e0e0;
        }

        .register-item:last-child {
            border-bottom: none;
        }

        .register-label {
            font-weight: 600;
            color: #555;
        }

        .register-value {
            font-family: 'Courier New', Courier, monospace;
            color: #333;
            font-size: 1em;
        }

        .explanation-panel p {
            line-height: 1.6;
            color: #444;
        }

        /* Data movement animation */
        .data-transfer {
            position: absolute;
            background-color: #ffc107; /* Yellow */
            border: 2px solid #e0a800; /* Added border for better visibility */
            border-radius: 50%;
            width: 24px; /* Slightly larger */
            height: 24px; /* Slightly larger */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75em; /* Adjusted font size */
            font-weight: bold;
            color: #333;
            opacity: 0;
            transform: scale(0);
            transition: all 0.7s ease-out; /* Slightly slower transition for movement */
            z-index: 10;
        }

        /* Media queries for responsiveness */
        @media (max-width: 992px) {
            .container {
                flex-direction: column;
                align-items: center;
                padding: 15px;
                max-width: 100vw; /* Use full width on smaller screens */
            }

            .controls-panel {
                width: 100%;
                max-width: 400px; /* Limit width on smaller screens */
                padding-right: 0;
                border-right: none;
                border-bottom: 1px solid #eee;
                padding-bottom: 20px;
                margin-bottom: 20px;
            }

            .cpu-layout {
                width: 100%;
                grid-template-areas:
                    "pc mar"
                    "mdr ir"
                    "cu alu"
                    "r1 r2"
                    "r3 r4"
                    "r5 mem"
                    "mem mem"; /* Adjust for smaller screens */
                grid-template-columns: 1fr 1fr;
                grid-auto-rows: minmax(70px, auto);
                padding: 15px;
                min-height: 400px; /* Adjust min-height for wrap */
            }

            .cpu-component {
                height: auto;
                padding: 10px;
                min-width: unset; /* Remove min-width */
            }

            .info-panel {
                flex-direction: column;
                width: 100%;
            }

            .register-panel, .explanation-panel {
                min-width: unset;
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            .input-group input[type="text"],
            button {
                font-size: 0.9em;
                padding: 10px 15px;
            }

            .btn-group {
                flex-direction: column;
            }
            .cpu-component .value {
                font-size: 0.9em;
            }
            .cpu-layout {
                grid-template-areas:
                    "pc ir"
                    "mar mdr"
                    "cu alu"
                    "r1 r2"
                    "r3 r4"
                    "r5 ."
                    "mem mem";
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls-panel">
            <h2>FDE Cycle Simulator</h2>
            <div class="input-group">
                <label for="instruction-input">Enter Instruction (e.g., ADD R1, R2):</label>
                <input type="text" id="instruction-input" placeholder="ADD R1, R2" value="ADD R1, R2">
            </div>
            <div class="btn-group">
                <button id="previous-step-btn" class="secondary" disabled>Previous Step</button>
                <button id="next-step-btn" class="primary">Next Step</button>
                <button id="restart-btn" class="secondary">Restart Simulation</button>
            </div>
            <div class="predefined-instructions">
                <h3>Predefined Instructions:</h3>
                <div class="instruction-list">
                    <button class="predefined-btn" data-instruction="ADD R1, R2">ADD R1, R2</button>
                    <button class="predefined-btn" data-instruction="SUB R3, R4">SUB R3, R4</button>
                    <button class="predefined-btn" data-instruction="MOV R5, #10">MOV R5, #10</button>
                    <button class="predefined-btn" data-instruction="MUL R1, R3">MUL R1, R3</button>
                    <button class="predefined-btn" data-instruction="DIV R2, R4">DIV R2, R4</button>
                </div>
            </div>
        </div>

        <div class="simulation-area">
            <div class="cpu-layout">
                <div id="pc" class="cpu-component"><div class="label">PC</div><div class="value">0x0000</div></div>
                <div id="mar" class="cpu-component"><div class="label">MAR</div><div class="value">---</div></div>
                <div id="mdr" class="cpu-component"><div class="label">MDR</div><div class="value">---</div></div>
                <div id="ir" class="cpu-component"><div class="label">IR</div><div class="value">---</div></div>
                <div id="cu" class="cpu-component"><div class="label">CU</div><div class="value">Idle</div></div>
                <div id="alu" class="cpu-component"><div class="label">ALU</div><div class="value">Ready</div></div>
                <div id="r1" class="cpu-component"><div class="label">R1</div><div class="value">5</div></div>
                <div id="r2" class="cpu-component"><div class="label">R2</div><div class="value">10</div></div>
                <div id="r3" class="cpu-component"><div class="label">R3</div><div class="value">7</div></div>
                <div id="r4" class="cpu-component"><div class="label">R4</div><div class="value">2</div></div>
                <div id="r5" class="cpu-component"><div class="label">R5</div><div class="value">0</div></div>
                <div id="memory-concept" class="cpu-component"><div class="label">Memory</div><div class="value">Instruction will be fetched here</div></div>
            </div>

            <div class="info-panel">
                <div class="register-panel">
                    <h3>Current Register Values</h3>
                    <div class="register-list">
                        <div class="register-item"><span class="register-label">PC:</span> <span id="reg-pc" class="register-value">0x0000</span></div>
                        <div class="register-item"><span class="register-label">MAR:</span> <span id="reg-mar" class="register-value">---</span></div>
                        <div class="register-item"><span class="register-label">MDR:</span> <span id="reg-mdr" class="register-value">---</span></div>
                        <div class="register-item"><span class="register-label">IR:</span> <span id="reg-ir" class="register-value">---</span></div>
                        <div class="register-item"><span class="register-label">R1:</span> <span id="reg-r1" class="register-value">5</span></div>
                        <div class="register-item"><span class="register-label">R2:</span> <span id="reg-r2" class="register-value">10</span></div>
                        <div class="register-item"><span class="register-label">R3:</span> <span id="reg-r3" class="register-value">7</span></div>
                        <div class="register-item"><span class="register-label">R4:</span> <span id="reg-r4" class="register-value">2</span></div>
                        <div class="register-item"><span class="register-label">R5:</span> <span id="reg-r5" class="register-value">0</span></div>
                    </div>
                </div>
                <div class="explanation-panel">
                    <h3>Current Stage Explanation</h3>
                    <p id="explanation-text">Welcome to the CPU Fetch-Decode-Execute Cycle Simulator! Enter an instruction and click "Next Step" to begin.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const instructionInput = document.getElementById('instruction-input');
        const nextStepBtn = document.getElementById('next-step-btn');
        const previousStepBtn = document.getElementById('previous-step-btn'); // New button
        const restartBtn = document.getElementById('restart-btn');
        const predefinedBtns = document.querySelectorAll('.predefined-btn');
        const cpuComponents = {
            pc: document.getElementById('pc'),
            mar: document.getElementById('mar'),
            mdr: document.getElementById('mdr'),
            ir: document.getElementById('ir'),
            cu: document.getElementById('cu'),
            alu: document.getElementById('alu'),
            r1: document.getElementById('r1'),
            r2: document.getElementById('r2'),
            r3: document.getElementById('r3'),
            r4: document.getElementById('r4'),
            r5: document.getElementById('r5'),
            memoryConcept: document.getElementById('memory-concept'),
        };
        const registerDisplays = {
            pc: document.getElementById('reg-pc'),
            mar: document.getElementById('reg-mar'),
            mdr: document.getElementById('reg-mdr'),
            ir: document.getElementById('reg-ir'),
            r1: document.getElementById('reg-r1'),
            r2: document.getElementById('reg-r2'),
            r3: document.getElementById('reg-r3'),
            r4: document.getElementById('reg-r4'),
            r5: document.getElementById('reg-r5'),
        };
        const explanationText = document.getElementById('explanation-text');
        const cpuLayout = document.querySelector('.cpu-layout');

        // CPU State
        let cpuState = {
            pc: 0x0000,
            mar: null,
            mdr: null,
            ir: null,
            registers: {
                R1: 5,
                R2: 10,
                R3: 7,
                R4: 2,
                R5: 0,
            },
            currentInstruction: null, // Stores parsed instruction details
            aluResult: null, // Stores ALU operation result for write-back stage
            stage: 0, // 0: Initial, 1: Fetch 1 (PC->MAR), ..., 7: Write-back
            maxStage: 7, // Max stage for a typical instruction
            history: [], // Stores previous cpuState snapshots for 'Previous Step'
        };

        // Stages and explanations
        const stageDescriptions = [
            "Welcome! Enter an instruction (e.g., ADD R1, R2) and click 'Next Step' to begin the simulation. You can also select a predefined instruction.", // Stage 0 (Initial)
            "**FETCH (1/3): PC to MAR** The Program Counter (PC) holds the address of the next instruction to be executed. This address is now transferred to the Memory Address Register (MAR). The MAR holds the address of the memory location to be accessed.", // Stage 1
            "**FETCH (2/3): Memory to MDR** The Control Unit (CU) sends a read signal to memory. The instruction stored at the address in MAR is fetched from memory and placed into the Memory Data Register (MDR).", // Stage 2
            "**FETCH (3/3): MDR to IR & PC Increment** The instruction is now moved from the MDR to the Instruction Register (IR). The IR holds the current instruction while it's being processed. Simultaneously, the Program Counter (PC) is incremented to point to the next instruction in sequence, preparing for the next cycle.", // Stage 3
            "**DECODE: IR to CU** The Control Unit (CU) takes the instruction from the IR and decodes it. This means the CU interprets what operation needs to be performed (e.g., ADD, SUB, MOV) and identifies the operands (e.g., R1, R2, or a literal value).", // Stage 4
            "**EXECUTE (1/3): Operands to ALU** The Control Unit directs the necessary data (operands) to the Arithmetic Logic Unit (ALU). For 'ADD R1, R2', the values stored in R1 and R2 are sent to the ALU's input registers.", // Stage 5
            "**EXECUTE (2/3): ALU Operation** The ALU performs the specified operation (addition, subtraction, etc.) on the operands. For 'ADD R1, R2', the ALU computes the sum of the values from R1 and R2.", // Stage 6
            "**EXECUTE (3/3) / WRITE-BACK: ALU Result to Destination Register** The result from the ALU is written back to the destination register. For 'ADD R1, R2', the sum calculated by the ALU is stored back into R1, updating its value. This completes the execution of the instruction.", // Stage 7
        ];

        // --- Utility Functions ---

        /**
         * Parses a simple instruction string into an object.
         * Supports: ADD R1, R2; SUB R3, R4; MOV R5, #10; MUL R1, R3; DIV R2, R4
         * @param {string} instructionStr
         * @returns {object|null} { opcode: string, dest: string, src1: string, literal?: number, full: string }
         */
        function parseInstruction(instructionStr) {
            const originalInstruction = instructionStr.trim(); // Store original full string
            const parts = originalInstruction.toUpperCase().split(/[\s,]+/);
            if (parts.length < 2) return null; // Needs at least opcode and one operand

            const opcode = parts[0];
            const dest = parts[1];
            let src1 = null;
            let literal = null;

            if (parts.length > 2) {
                if (parts[2].startsWith('#')) {
                    literal = parseInt(parts[2].substring(1), 10);
                    if (isNaN(literal)) return null;
                } else {
                    src1 = parts[2];
                }
            }
            return { opcode, dest, src1, literal, full: originalInstruction };
        }

        /**
         * Updates the text content of a CPU component value.
         * @param {HTMLElement} componentDiv - The DOM element of the CPU component.
         * @param {string|number} value - The new value to display.
         */
        function updateComponentValue(componentDiv, value) {
            const valueSpan = componentDiv.querySelector('.value');
            if (valueSpan) {
                valueSpan.textContent = value;
            }
        }

        /**
         * Highlights a CPU component by adding an 'active' class.
         * @param {HTMLElement} componentDiv
         */
        function highlightComponent(componentDiv) {
            if (componentDiv) {
                componentDiv.classList.add('active');
            }
        }

        /**
         * Removes highlight from all CPU components.
         */
        function clearHighlights() {
            Object.values(cpuComponents).forEach(comp => {
                if (comp) comp.classList.remove('active');
            });
        }

        /**
         * Animates data transfer from source to destination.
         * @param {HTMLElement} sourceElement
         * @param {HTMLElement} destElement
         * @param {string|number} dataValue
         */
        function animateDataTransfer(sourceElement, destElement, dataValue) {
            if (!sourceElement || !destElement) return;

            const transferEl = document.createElement('div');
            transferEl.classList.add('data-transfer');
            transferEl.textContent = dataValue;

            const startRect = sourceElement.getBoundingClientRect();
            const endRect = destElement.getBoundingClientRect();
            const layoutRect = cpuLayout.getBoundingClientRect();

            // Calculate positions relative to the cpuLayout container
            const startX = startRect.left - layoutRect.left + startRect.width / 2 - transferEl.offsetWidth / 2;
            const startY = startRect.top - layoutRect.top + startRect.height / 2 - transferEl.offsetHeight / 2;
            const endX = endRect.left - layoutRect.left + endRect.width / 2 - transferEl.offsetWidth / 2;
            const endY = endRect.top - layoutRect.top + endRect.height / 2 - transferEl.offsetHeight / 2;

            transferEl.style.left = `${startX}px`;
            transferEl.style.top = `${startY}px`;
            cpuLayout.appendChild(transferEl);

            // Trigger animation after appending to ensure CSS transition works
            requestAnimationFrame(() => {
                transferEl.style.opacity = '1';
                transferEl.style.transform = 'scale(1)';
                transferEl.style.left = `${endX}px`;
                transferEl.style.top = `${endY}px`;
            });

            // Remove the element after animation completes
            setTimeout(() => {
                transferEl.style.opacity = '0';
                transferEl.style.transform = 'scale(0)';
                transferEl.addEventListener('transitionend', () => transferEl.remove(), { once: true });
            }, 700); // Match animation duration
        }

        /**
         * Updates all register values in the register panel.
         */
        function updateRegisterPanel() {
            registerDisplays.pc.textContent = `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`;
            registerDisplays.mar.textContent = cpuState.mar !== null ? `0x${cpuState.mar.toString(16).padStart(4, '0').toUpperCase()}` : '---';
            registerDisplays.mdr.textContent = cpuState.mdr !== null ? cpuState.mdr : '---';
            registerDisplays.ir.textContent = cpuState.ir !== null ? cpuState.ir : '---';

            for (const reg in cpuState.registers) {
                if (registerDisplays[reg.toLowerCase()]) {
                    registerDisplays[reg.toLowerCase()].textContent = cpuState.registers[reg];
                }
            }
        }

        /**
         * Updates the state of the navigation buttons (Next, Previous).
         */
        function updateButtonStates() {
            // Next Step button
            if (cpuState.currentInstruction && cpuState.stage <= cpuState.maxStage) {
                nextStepBtn.classList.remove('disabled');
                nextStepBtn.disabled = false;
                nextStepBtn.textContent = "Next Step";
            } else {
                nextStepBtn.classList.add('disabled');
                nextStepBtn.disabled = true;
                if (cpuState.currentInstruction) { // Only change text if an instruction was successfully parsed
                    nextStepBtn.textContent = "Simulation Complete!";
                } else {
                    nextStepBtn.textContent = "Next Step"; // Reset text if instruction parsing failed
                }
            }

            // Previous Step button
            // Can go back if history exists and not at initial stage (stage 0)
            if (cpuState.history.length > 0 && cpuState.stage > 0) {
                previousStepBtn.classList.remove('disabled');
                previousStepBtn.disabled = false;
            } else {
                previousStepBtn.classList.add('disabled');
                previousStepBtn.disabled = true;
            }
        }

        // --- Simulation Stages ---

        function advanceSimulation() {
            // Save current state to history BEFORE advancing
            const stateToSave = JSON.parse(JSON.stringify(cpuState)); // Deep copy
            delete stateToSave.history; // Don't include history in the history snapshot itself
            cpuState.history.push(stateToSave);

            // Handle instruction parsing at stage 0
            if (cpuState.stage === 0) {
                const instructionStr = instructionInput.value.trim();
                cpuState.currentInstruction = parseInstruction(instructionStr);
                if (!cpuState.currentInstruction) {
                    explanationText.innerHTML = "<span style='color: red; font-weight: bold;'>Error: Invalid instruction format.</span><br>Please use format like 'ADD R1, R2', 'SUB R3, R4', 'MOV R5, #10', etc. Check for typos.";
                    // If parsing failed, remove the invalid state that was just pushed to history
                    if (cpuState.history.length > 0) {
                        cpuState.history.pop();
                    }
                    nextStepBtn.classList.add('disabled');
                    nextStepBtn.disabled = true;
                    updateButtonStates(); // Update button state immediately
                    return; // Stop simulation if instruction is invalid
                }
                // If instruction was parsed successfully, ensure it's in the current history snapshot
                // This is important if user immediately goes back to stage 0 after successful parsing.
                if (cpuState.history.length > 0) {
                    cpuState.history[cpuState.history.length - 1].currentInstruction = JSON.parse(JSON.stringify(cpuState.currentInstruction));
                }
            }

            clearHighlights(); // Clear highlights from previous step
            explanationText.innerHTML = stageDescriptions[cpuState.stage]; // Update explanation for current stage

            // CRITICAL CHECK: Ensure currentInstruction is available for all stages > 0
            // If it's null here, it means something went wrong in parsing or state restoration.
            if (cpuState.stage > 0 && !cpuState.currentInstruction) {
                explanationText.innerHTML = "<span style='color: red; font-weight: bold;'>Critical Error: Instruction information missing.</span> Please restart the simulation.";
                nextStepBtn.classList.add('disabled');
                nextStepBtn.disabled = true;
                updateButtonStates();
                return;
            }

            // Execute logic for the current stage
            switch (cpuState.stage) {
                case 0:
                    // This case primarily handles the initial state setup and instruction parsing.
                    // No direct component animation/updates needed for the 'initial' conceptual stage itself.
                    break;
                case 1: // FETCH (1/3): PC to MAR
                    highlightComponent(cpuComponents.pc);
                    highlightComponent(cpuComponents.mar);
                    updateComponentValue(cpuComponents.pc, `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`);
                    animateDataTransfer(cpuComponents.pc, cpuComponents.mar, `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`);
                    cpuState.mar = cpuState.pc;
                    updateComponentValue(cpuComponents.mar, `0x${cpuState.mar.toString(16).padStart(4, '0').toUpperCase()}`);
                    break;
                case 2: // FETCH (2/3): Memory to MDR
                    highlightComponent(cpuComponents.memoryConcept);
                    highlightComponent(cpuComponents.mdr);
                    // Use cpuState.currentInstruction.full to display the full instruction in memory
                    updateComponentValue(cpuComponents.memoryConcept, cpuState.currentInstruction.full);
                    animateDataTransfer(cpuComponents.memoryConcept, cpuComponents.mdr, cpuState.currentInstruction.full);
                    cpuState.mdr = cpuState.currentInstruction.full;
                    updateComponentValue(cpuComponents.mdr, cpuState.mdr);
                    break;
                case 3: // FETCH (3/3): MDR to IR & PC Increment
                    highlightComponent(cpuComponents.mdr);
                    highlightComponent(cpuComponents.ir);
                    highlightComponent(cpuComponents.pc);
                    animateDataTransfer(cpuComponents.mdr, cpuComponents.ir, cpuState.mdr);
                    cpuState.ir = cpuState.mdr;
                    updateComponentValue(cpuComponents.ir, cpuState.ir);
                    // PC increments (assuming 4-byte instructions for simplicity)
                    cpuState.pc += 4;
                    updateComponentValue(cpuComponents.pc, `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`);
                    break;
                case 4: // DECODE: IR to CU
                    highlightComponent(cpuComponents.ir);
                    highlightComponent(cpuComponents.cu);
                    updateComponentValue(cpuComponents.cu, 'Decoding...');
                    // Simulate decoding process
                    setTimeout(() => updateComponentValue(cpuComponents.cu, `Decoded: ${cpuState.currentInstruction.opcode}`), 400);
                    break;
                case 5: // EXECUTE (1/3): Operands to ALU
                    highlightComponent(cpuComponents.cu); // CU directs
                    highlightComponent(cpuComponents.alu);
                    const destRegEl = cpuComponents[cpuState.currentInstruction.dest.toLowerCase()];
                    const src1RegEl = cpuState.currentInstruction.src1 ? cpuComponents[cpuState.currentInstruction.src1.toLowerCase()] : null;
                    const literalVal = cpuState.currentInstruction.literal;

                    const operandValue1 = cpuState.registers[cpuState.currentInstruction.dest.toUpperCase()];
                    let operandValue2;

                    if (src1RegEl) { // Two register operands (e.g., ADD R1, R2)
                        highlightComponent(destRegEl);
                        highlightComponent(src1RegEl);
                        operandValue2 = cpuState.registers[cpuState.currentInstruction.src1.toUpperCase()];
                        animateDataTransfer(destRegEl, cpuComponents.alu, operandValue1);
                        setTimeout(() => animateDataTransfer(src1RegEl, cpuComponents.alu, operandValue2), 200); // Slight delay for visual separation
                        updateComponentValue(cpuComponents.alu, `Loading ${operandValue1}, ${operandValue2}`);
                    } else if (literalVal !== null && literalVal !== undefined) { // Register and literal (e.g., MOV R5, #10)
                        highlightComponent(destRegEl);
                        operandValue2 = literalVal;
                        // Animate dest register value to ALU (even if it's not directly used for MOV's calculation)
                        animateDataTransfer(destRegEl, cpuComponents.alu, operandValue1);
                        // Simulate literal value movement
                        const tempLiteralEl = document.createElement('div');
                        tempLiteralEl.classList.add('data-transfer'); // Re-use data-transfer style
                        tempLiteralEl.textContent = `#${literalVal}`;
                        tempLiteralEl.style.left = `${destRegEl.offsetLeft - 50}px`; // Start near dest for visual
                        tempLiteralEl.style.top = `${destRegEl.offsetTop + destRegEl.offsetHeight / 2}px`;
                        tempLiteralEl.style.opacity = '0';
                        tempLiteralEl.style.transform = 'scale(0)';
                        cpuLayout.appendChild(tempLiteralEl);

                        requestAnimationFrame(() => {
                            tempLiteralEl.style.transition = 'all 0.7s ease-out';
                            tempLiteralEl.style.opacity = '1';
                            tempLiteralEl.style.transform = 'scale(1)';
                            const aluRect = cpuComponents.alu.getBoundingClientRect();
                            const layoutRect = cpuLayout.getBoundingClientRect();
                            tempLiteralEl.style.left = `${aluRect.left - layoutRect.left + aluRect.width / 2 - tempLiteralEl.offsetWidth / 2}px`;
                            tempLiteralEl.style.top = `${aluRect.top - layoutRect.top + aluRect.height / 2 - tempLiteralEl.offsetHeight / 2}px`;
                        });
                        setTimeout(() => tempLiteralEl.remove(), 700); // Remove temp element
                        updateComponentValue(cpuComponents.alu, `Loading ${operandValue1}, #${operandValue2}`);
                    }
                    break;
                case 6: // EXECUTE (2/3): ALU Operation
                    highlightComponent(cpuComponents.alu);
                    updateComponentValue(cpuComponents.alu, `Performing ${cpuState.currentInstruction.opcode}...`);

                    let result;
                    const currentDestReg = cpuState.currentInstruction.dest.toUpperCase();
                    const currentSrc1Reg = cpuState.currentInstruction.src1 ? cpuState.currentInstruction.src1.toUpperCase() : null;
                    const currentLiteralVal = cpuState.currentInstruction.literal;

                    const val1 = cpuState.registers[currentDestReg];
                    const val2 = currentSrc1Reg ? cpuState.registers[currentSrc1Reg] : currentLiteralVal;

                    switch (cpuState.currentInstruction.opcode) {
                        case 'ADD':
                            result = val1 + val2;
                            break;
                        case 'SUB':
                            result = val1 - val2;
                            break;
                        case 'MUL':
                            result = val1 * val2;
                            break;
                        case 'DIV':
                            result = val2 !== 0 ? Math.floor(val1 / val2) : 'Error: Div by 0'; // Handle division by zero
                            break;
                        case 'MOV':
                            result = val2; // MOV's result is just the source value
                            break;
                        default:
                            result = 'N/A';
                    }
                    cpuState.aluResult = result; // Store result for next stage
                    setTimeout(() => updateComponentValue(cpuComponents.alu, `Result: ${result}`), 600);
                    break;
                case 7: // EXECUTE (3/3) / WRITE-BACK: ALU Result to Destination Register
                    highlightComponent(cpuComponents.alu);
                    const destRegWriteBackEl = cpuComponents[cpuState.currentInstruction.dest.toLowerCase()];
                    if (destRegWriteBackEl) {
                        highlightComponent(destRegWriteBackEl);
                        if (typeof cpuState.aluResult === 'number') { // Only update if it's a valid number
                            animateDataTransfer(cpuComponents.alu, destRegWriteBackEl, cpuState.aluResult);
                            cpuState.registers[cpuState.currentInstruction.dest.toUpperCase()] = cpuState.aluResult;
                            updateComponentValue(destRegWriteBackEl, cpuState.aluResult);
                        } else {
                            // Display error if division by zero occurred
                            updateComponentValue(destRegWriteBackEl, cpuState.aluResult);
                        }
                    }
                    updateComponentValue(cpuComponents.alu, 'Ready'); // ALU returns to ready state
                    break;
                default:
                    console.error("Unknown stage:", cpuState.stage);
            }

            // Update all component values and register panel after each stage
            updateComponentValue(cpuComponents.pc, `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`);
            updateComponentValue(cpuComponents.mar, cpuState.mar !== null ? `0x${cpuState.mar.toString(16).padStart(4, '0').toUpperCase()}` : '---');
            updateComponentValue(cpuComponents.mdr, cpuState.mdr !== null ? cpuState.mdr : '---');
            updateComponentValue(cpuComponents.ir, cpuState.ir !== null ? cpuState.ir : '---');
            Object.keys(cpuState.registers).forEach(reg => {
                updateComponentValue(cpuComponents[reg.toLowerCase()], cpuState.registers[reg]);
            });

            updateRegisterPanel(); // Ensure UI reflects the new state
            cpuState.stage++;
            updateButtonStates(); // Update button states after incrementing stage
        }

        /**
         * Goes back one step in the simulation history.
         */
        function goBackSimulation() {
            if (cpuState.history.length > 0) {
                // Pop the current state (which was saved before advancing to the current stage)
                cpuState.history.pop();
                if (cpuState.history.length > 0) {
                    // Load the previous state from history
                    const prevState = JSON.parse(JSON.stringify(cpuState.history[cpuState.history.length - 1]));
                    Object.assign(cpuState, prevState);
                    cpuState.stage = prevState.stage; // Restore previous stage
                } else {
                    // If history is empty after pop, revert to initial state
                    resetSimulation();
                    return; // Exit early as resetSimulation handles button states
                }

                clearHighlights();
                // Ensure explanation corresponds to the restored stage *before* re-rendering values
                explanationText.innerHTML = stageDescriptions[cpuState.stage];

                // Update all component values based on the restored state
                updateComponentValue(cpuComponents.pc, `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`);
                updateComponentValue(cpuComponents.mar, cpuState.mar !== null ? `0x${cpuState.mar.toString(16).padStart(4, '0').toUpperCase()}` : '---');
                updateComponentValue(cpuComponents.mdr, cpuState.mdr !== null ? cpuState.mdr : '---');
                updateComponentValue(cpuComponents.ir, cpuState.ir !== null ? cpuState.ir : '---');
                // Restore CU and ALU text based on the stage
                updateComponentValue(cpuComponents.cu, (cpuState.stage === 4 && cpuState.currentInstruction ? `Decoded: ${cpuState.currentInstruction.opcode}` : 'Idle'));
                updateComponentValue(cpuComponents.alu, (cpuState.stage === 6 ? `Result: ${cpuState.aluResult}` : 'Ready'));
                updateComponentValue(cpuComponents.memoryConcept, cpuState.currentInstruction ? cpuState.currentInstruction.full : 'Instruction will be fetched here');

                Object.keys(cpuState.registers).forEach(reg => {
                    updateComponentValue(cpuComponents[reg.toLowerCase()], cpuState.registers[reg]);
                });

                updateRegisterPanel();
                updateButtonStates(); // Update button states after restoring state
            }
        }


        /**
         * Resets the simulation to its initial state.
         */
        function resetSimulation() {
            cpuState = {
                pc: 0x0000,
                mar: null,
                mdr: null,
                ir: null,
                registers: {
                    R1: 5,
                    R2: 10,
                    R3: 7,
                    R4: 2,
                    R5: 0,
                },
                currentInstruction: null,
                aluResult: null,
                stage: 0,
                maxStage: 7,
                history: [], // Clear history on reset
            };
            clearHighlights();
            updateComponentValue(cpuComponents.pc, `0x${cpuState.pc.toString(16).padStart(4, '0').toUpperCase()}`);
            updateComponentValue(cpuComponents.mar, '---');
            updateComponentValue(cpuComponents.mdr, '---');
            updateComponentValue(cpuComponents.ir, '---');
            updateComponentValue(cpuComponents.cu, 'Idle');
            updateComponentValue(cpuComponents.alu, 'Ready');
            updateComponentValue(cpuComponents.memoryConcept, 'Instruction will be fetched here');
            Object.keys(cpuState.registers).forEach(reg => {
                updateComponentValue(cpuComponents[reg.toLowerCase()], cpuState.registers[reg]);
            });

            instructionInput.value = "ADD R1, R2"; // Reset input to default
            explanationText.textContent = stageDescriptions[0];
            updateRegisterPanel(); // Update register panel with initial values
            updateButtonStates(); // Update button states after reset
        }

        // --- Event Listeners ---
        nextStepBtn.addEventListener('click', advanceSimulation);
        previousStepBtn.addEventListener('click', goBackSimulation); // Event listener for previous step
        restartBtn.addEventListener('click', resetSimulation);

        predefinedBtns.forEach(btn => {
            btn.addEventListener('click', (event) => {
                instructionInput.value = event.target.dataset.instruction;
                resetSimulation(); // Reset simulation state when a new instruction is selected
            });
        });

        // Initialize on page load
        window.onload = function() {
            resetSimulation();
        };

    </script>
</body>
</html>
